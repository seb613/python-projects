"""
This type stub file was generated by pyright.
"""

import executing
from contextlib import contextmanager
from pygments.formatters import Terminal256Formatter
from pygments.lexers import Python3Lexer as Py3Lexer, PythonLexer as PyLexer
from .coloring import SolarizedDark

PYTHON2 = ...
_absent = ...
def bindStaticVariable(name, value): # -> Callable[..., Any]:
    ...

@bindStaticVariable('formatter', Terminal256Formatter(style=SolarizedDark))
@bindStaticVariable('lexer', PyLexer(ensurenl=False) if PYTHON2 else Py3Lexer(ensurenl=False))
def colorize(s): # -> Any:
    ...

@contextmanager
def supportTerminalColorsInWindows(): # -> Generator[None, Any, None]:
    ...

def stderrPrint(*args): # -> None:
    ...

def isLiteral(s): # -> bool:
    ...

def colorizedStderrPrint(s): # -> None:
    ...

DEFAULT_PREFIX = ...
DEFAULT_LINE_WRAP_WIDTH = ...
DEFAULT_CONTEXT_DELIMITER = ...
DEFAULT_OUTPUT_FUNCTION = ...
DEFAULT_ARG_TO_STRING_FUNCTION = ...
class NoSourceAvailableError(OSError):
    """
    Raised when icecream fails to find or access source code that's
    required to parse and analyze. This can happen, for example, when

      - ic() is invoked inside a REPL or interactive shell, e.g. from the
        command line (CLI) or with python -i.

      - The source code is mangled and/or packaged, e.g. with a project
        freezer like PyInstaller.

      - The underlying source code changed during execution. See
        https://stackoverflow.com/a/33175832.
    """
    infoMessage = ...


def callOrValue(obj): # -> object:
    ...

class Source(executing.Source):
    def get_text_with_indentation(self, node): # -> str:
        ...
    


def prefixLinesAfterFirst(prefix, s): # -> str:
    ...

def indented_lines(prefix, string): # -> list[Any]:
    ...

def format_pair(prefix, arg, value): # -> LiteralString:
    ...

def singledispatch(func): # -> _SingleDispatchCallable[Any]:
    ...

@singledispatch
def argumentToString(obj): # -> str:
    ...

class IceCreamDebugger:
    _pairDelimiter = ...
    lineWrapWidth = ...
    contextDelimiter = ...
    def __init__(self, prefix=..., outputFunction=..., argToStringFunction=..., includeContext=..., contextAbsPath=...) -> None:
        ...
    
    def __call__(self, *args): # -> tuple[Any, ...] | None:
        ...
    
    def format(self, *args): # -> str | LiteralString:
        ...
    
    def enable(self): # -> None:
        ...
    
    def disable(self): # -> None:
        ...
    
    def configureOutput(self, prefix=..., outputFunction=..., argToStringFunction=..., includeContext=..., contextAbsPath=...): # -> None:
        ...
    


ic = ...
